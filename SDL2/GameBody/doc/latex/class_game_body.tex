\hypertarget{class_game_body}{}\section{Game\+Body类 参考}
\label{class_game_body}\index{GameBody@{GameBody}}


这个类封装了很多的\+S\+D\+L方法，方便你去快速构建一个应用  




{\ttfamily \#include $<$Game\+Body.\+hpp$>$}

\subsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_game_body_ab0ab54f534157a3bfc545bcbf9136455}{Game\+Body}} (const string, int width, int height, Uint32, int delaytime)
\begin{DoxyCompactList}\small\item\em 构造函数 \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_game_body_a87994250c16faae42aeb68ff98031589}{event\+Handle}} ()
\begin{DoxyCompactList}\small\item\em 事件处理函数，你可以重写这个事件来给出你自己的处理过程。这个里面只是给出了退出事件的监测 \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_game_body_abeff43d0ab34cf69977c386736953552}{update}} ()
\begin{DoxyCompactList}\small\item\em 每一帧要执行的代码，你几乎必须重写这个函数来实现你自己的功能（除非你想要一个不做任何事情的窗口） \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_game_body_a4eca53ae69ac545e3e3666d7929a9cf4}{step}} ()
\begin{DoxyCompactList}\small\item\em 你必须在循环里面显式的调用这个函数。这个函数里面按照流程调用了update()和一些其他的函数 \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_game_body_a402e91bd648142d2b4925a6923860852}{delay}} (int millisec)
\begin{DoxyCompactList}\small\item\em 每一帧延时的时间 \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_game_body_a9ec4c012ae72dd25d849d6ebacb9357c}{is\+Quit}} ()
\begin{DoxyCompactList}\small\item\em 你不应该重写这个函数，它是用于在循环里面判断是否退出程序的函数 \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_game_body_a804c0e5d53cf79d8b4262ece694be204}{clean}} ()
\begin{DoxyCompactList}\small\item\em 会在析构函数里面调用，用于程序最后的清楚 \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{class_game_body_af13feb5fae1c033d524dae6210dd58ef}{$\sim$\+Game\+Body}} ()
\begin{DoxyCompactList}\small\item\em 析构函数 \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{详细描述}
这个类封装了很多的\+S\+D\+L方法，方便你去快速构建一个应用 

\begin{DoxyWarning}{警告}
你的子类的构造函数不可以有参数，而且必须只有一个无参构造函数。
\end{DoxyWarning}
这个类的用法是这样： 如果你对窗体的要求不是很高的话，可以只重写update()函数来添加你自己的功能。如果需要对事件处理进行改动的话你需要重写event\+Handle()函数。你也可以重写clean()函数来清空资源。所有的虚函数都是可以重写的，但是我们不建议你写我们没有显式说明可以重写的函数 基本的流程是这样： 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }myClass:\textcolor{keyword}{public} \mbox{\hyperlink{class_game_body}{GameBody}}\{}
\DoxyCodeLine{    myClass():\mbox{\hyperlink{class_game_body}{GameBody}}(yourtitle,yourwidth,yourheight,yourflag,yourmillisec)\{}
\DoxyCodeLine{        \textcolor{comment}{//TODO Initialize....}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{ \textcolor{comment}{//TODO Other Override....}}
\DoxyCodeLine{\};}
\DoxyCodeLine{ }
\DoxyCodeLine{\mbox{\hyperlink{_game_body_8hpp_ac494cf2f7d1cfa8a6b234c1f635a937b}{RUN\_APP}}(myClass);}
\DoxyCodeLine{\}}
\end{DoxyCode}
 

\subsection{构造及析构函数说明}
\mbox{\Hypertarget{class_game_body_ab0ab54f534157a3bfc545bcbf9136455}\label{class_game_body_ab0ab54f534157a3bfc545bcbf9136455}} 
\index{GameBody@{GameBody}!GameBody@{GameBody}}
\index{GameBody@{GameBody}!GameBody@{GameBody}}
\subsubsection{\texorpdfstring{GameBody()}{GameBody()}}
{\footnotesize\ttfamily Game\+Body\+::\+Game\+Body (\begin{DoxyParamCaption}\item[{const string}]{title,  }\item[{int}]{width,  }\item[{int}]{height,  }\item[{Uint32}]{flag,  }\item[{int}]{delaytime }\end{DoxyParamCaption})}



构造函数 


\begin{DoxyParams}{参数}
{\em title} & 窗口的标题 \\
\hline
{\em width} & 窗口宽度 \\
\hline
{\em height} & 窗口高度 \\
\hline
{\em flag} & 传递给\+S\+D\+L\+\_\+\+Create\+Window()函数的参数，指定窗口的类型 \\
\hline
{\em delaytime} & 每一帧延时的时间 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_game_body_af13feb5fae1c033d524dae6210dd58ef}\label{class_game_body_af13feb5fae1c033d524dae6210dd58ef}} 
\index{GameBody@{GameBody}!````~GameBody@{$\sim$GameBody}}
\index{````~GameBody@{$\sim$GameBody}!GameBody@{GameBody}}
\subsubsection{\texorpdfstring{$\sim$GameBody()}{~GameBody()}}
{\footnotesize\ttfamily Game\+Body\+::$\sim$\+Game\+Body (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



析构函数 



\subsection{成员函数说明}
\mbox{\Hypertarget{class_game_body_a804c0e5d53cf79d8b4262ece694be204}\label{class_game_body_a804c0e5d53cf79d8b4262ece694be204}} 
\index{GameBody@{GameBody}!clean@{clean}}
\index{clean@{clean}!GameBody@{GameBody}}
\subsubsection{\texorpdfstring{clean()}{clean()}}
{\footnotesize\ttfamily virtual void Game\+Body\+::clean (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



会在析构函数里面调用，用于程序最后的清楚 

fn \mbox{\hyperlink{class_game_body_a804c0e5d53cf79d8b4262ece694be204}{clean()}} \begin{DoxyReturn}{返回}
如果app结束返回true，否则返回false 
\end{DoxyReturn}
\mbox{\Hypertarget{class_game_body_a402e91bd648142d2b4925a6923860852}\label{class_game_body_a402e91bd648142d2b4925a6923860852}} 
\index{GameBody@{GameBody}!delay@{delay}}
\index{delay@{delay}!GameBody@{GameBody}}
\subsubsection{\texorpdfstring{delay()}{delay()}}
{\footnotesize\ttfamily Game\+Body\+::delay (\begin{DoxyParamCaption}\item[{int}]{millisec }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



每一帧延时的时间 


\begin{DoxyParams}{参数}
{\em millisec} & 延时的时间，为微秒 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_game_body_a87994250c16faae42aeb68ff98031589}\label{class_game_body_a87994250c16faae42aeb68ff98031589}} 
\index{GameBody@{GameBody}!eventHandle@{eventHandle}}
\index{eventHandle@{eventHandle}!GameBody@{GameBody}}
\subsubsection{\texorpdfstring{eventHandle()}{eventHandle()}}
{\footnotesize\ttfamily Game\+Body\+::event\+Handle (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



事件处理函数，你可以重写这个事件来给出你自己的处理过程。这个里面只是给出了退出事件的监测 

\mbox{\Hypertarget{class_game_body_a9ec4c012ae72dd25d849d6ebacb9357c}\label{class_game_body_a9ec4c012ae72dd25d849d6ebacb9357c}} 
\index{GameBody@{GameBody}!isQuit@{isQuit}}
\index{isQuit@{isQuit}!GameBody@{GameBody}}
\subsubsection{\texorpdfstring{isQuit()}{isQuit()}}
{\footnotesize\ttfamily Game\+Body\+::is\+Quit (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



你不应该重写这个函数，它是用于在循环里面判断是否退出程序的函数 

\mbox{\Hypertarget{class_game_body_a4eca53ae69ac545e3e3666d7929a9cf4}\label{class_game_body_a4eca53ae69ac545e3e3666d7929a9cf4}} 
\index{GameBody@{GameBody}!step@{step}}
\index{step@{step}!GameBody@{GameBody}}
\subsubsection{\texorpdfstring{step()}{step()}}
{\footnotesize\ttfamily Game\+Body\+::step (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



你必须在循环里面显式的调用这个函数。这个函数里面按照流程调用了update()和一些其他的函数 

\mbox{\Hypertarget{class_game_body_abeff43d0ab34cf69977c386736953552}\label{class_game_body_abeff43d0ab34cf69977c386736953552}} 
\index{GameBody@{GameBody}!update@{update}}
\index{update@{update}!GameBody@{GameBody}}
\subsubsection{\texorpdfstring{update()}{update()}}
{\footnotesize\ttfamily Game\+Body\+::update (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



每一帧要执行的代码，你几乎必须重写这个函数来实现你自己的功能（除非你想要一个不做任何事情的窗口） 



该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{_game_body_8hpp}{Game\+Body.\+hpp}}\item 
\mbox{\hyperlink{_game_body_8cpp}{Game\+Body.\+cpp}}\end{DoxyCompactItemize}
